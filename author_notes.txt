Проект использует boost, для сборки в MSVC переменная окружения "BOOST" должна быть определена

Основная идея решения заключается в том что будет использована многопоточность.
Программа узнаёт у ОС кол-во доступных ядер и использует
* одно для чтения входного файла
* одно для записи хешей
* оставшиеся (либо 1 если ядер < 3) для вычислений.

Разделяемым объектом выступает CParallelTaskManager (через интерфейс ITaskManager).
Он передаётся всем потокам, а сам хранит обрабатываемые данные и контроллирует одновременный доступ
Замечание: в проекте есть еще одна реализация ITaskManager - CNonParallelTaskManager. Она служила мне для того чтобы в начале разработки быстро получить работающее приложение и отладить большую часть ошибок а потом сконцентрироваться на оптимальной реализации. В финальной версии не используется

CParallelTaskManager содержит две очереди элементами которых выступают указатели на обрабатываемые объекты.
Когда из входного файла читается новая партия данных то на создаваемый объект указатель добавляется в обе очереди (в конец):
Из первой очереди читают потоки вычисляющие хеш. Посли его вычисления объект с данными получает состояние "готов к записи результата"
Из второй очереди читает поток который записывает результат.
Такая система (из двух очередей) позволяет записывать хешы в том порядке в котором были прочитаны соответствующие входные блоки данных.
Можно было бы обойтись одной общей очередью но в таком случае возникает проблема с вычислением элемента который нужно отдать сейчас на хеширование, в случае же с двумя - он всегда в начале одной из очередей (откуда посли передачи на подсчет он удаляется, а вот из второй очереди он удаляется только после записи результата соответствующего этому блоку)

Чтение притормаживается если запись результатов (и/или) выполняется медленнее чем идёт чтение. Таким образом - очереди всегда имеют ограниченный размер (реализация требования по ограниченной памяти)

Хеш подсчитывается как md5. Использована boost.

Код не является кросс-платформенным однако я постарался свести к минимуму платформо-зависисмость.
Для того чтобы код стал кроссплатформенным требуется
- реализовать ICustomCriticalSection для новой целевой платформы (сейчас используются обернутые в RAII крититческие секции Windows)
- описатиь в CParallelTaskManager::countPossibleAmountOfWorkerThreads() вычисление кол-ва процессорных ядер для новой целевой платформы


